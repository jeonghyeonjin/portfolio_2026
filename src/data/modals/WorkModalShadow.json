{
  "sections": {
    "projectOverview": {
      "title": "ğŸ“Œ Project Overview | í”„ë¡œì íŠ¸ ê°œìš”",
      "paragraphs": [
        "ShadowëŠ” AI ê¸°ë°˜ ì‹¤ì‹œê°„ íšŒì˜ ê¸°ë¡ ë° ë¶„ì„ ì• í”Œë¦¬ì¼€ì´ì…˜ì…ë‹ˆë‹¤. macOSì—ì„œ ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ë¥¼ ìº¡ì²˜í•˜ê³ , ìë™ìœ¼ë¡œ í…ìŠ¤íŠ¸ ë³€í™˜ ë° ìš”ì•½ì„ ì œê³µí•˜ëŠ” ë°ìŠ¤í¬í†± ì•±ì…ë‹ˆë‹¤.",
        "Flutterë¥¼ ì‚¬ìš©í•˜ì—¬ ê°œë°œì„ ì§„í–‰í–ˆìœ¼ë©°, GetXë¥¼ í™œìš©í•œ ìƒíƒœ ê´€ë¦¬ì™€ ë„¤ì´í‹°ë¸Œ í”ŒëŸ¬ê·¸ì¸ ì—°ë™ì„ í†µí•´ ê³ ì„±ëŠ¥ ì•±ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤."
      ]
    },
    "techStack": {
      "title": "ğŸ› ï¸ Tech Stack Summary"
    },
    "logoDesign": {
      "title": "ğŸ¨ Logo Design | ë¡œê³  ë””ìì¸",
      "description": "Shadow ë¡œê³ ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ìœ¼ë¡œ ë°œì „í•˜ë©° ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì›í˜•ì˜ ë¬¼ì²´ê°€ ê·¸ë¦¼ìë¥¼ ë°›ì€ ëª¨ì–‘ì„ í˜•ìƒí™”í•œ í›„, ê·¸ë¦¼ìë§Œ ë”°ì„œ Shadowì˜ Sìë¥¼ ê·¸ë ¤ëƒˆìŠµë‹ˆë‹¤.",
      "logoLabels": ["ë¬¼ì²´ì— ê·¸ë¦¼ìê°€ ìƒê¸´ ëª¨ìŠµ", "ê·¸ë¦¼ì ëª¨ì–‘ì„ í˜•ìƒí™”", "Shadowì˜ S", "Final"]
    },
    "keyContributions": {
      "title": "ğŸ¨ My Key Contributions"
    },
    "performanceImpact": {
      "title": "ğŸ“ˆ Performance Impact"
    },
    "keyTakeaways": {
      "title": "ğŸ¯ Key Takeaways",
      "takeaways": [
        {
          "title": "Performance & UX Engineering:",
          "items": [
            "<strong>Zero-Latency Experience:</strong> Predictive Preloadingì„ í†µí•´ ì´ë¯¸ì§€ ë¡œë”© ì‹œê°„ì„ 100% ì œê±°í•˜ì—¬ ëŠê¹€ ì—†ëŠ” ì‚¬ìš©ì ê²½í—˜ ì œê³µ",
            "<strong>Keyboard-First Design:</strong> ë§ˆìš°ìŠ¤ ì—†ì´ ëª¨ë“  ê¸°ëŠ¥ ì¡°ì‘ ê°€ëŠ¥í•œ ë°ìŠ¤í¬í†±ê¸‰ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„",
            "<strong>Memory Optimization:</strong> ìŠ¤ë§ˆíŠ¸ ìºì‹± ì‹œìŠ¤í…œìœ¼ë¡œ ëŒ€ìš©ëŸ‰ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ê·¹ëŒ€í™”"
          ]
        },
        {
          "title": "System Integration & Architecture:",
          "items": [
            "<strong>API Optimization:</strong> Google Calendar API ì¦ë¶„ ë™ê¸°í™”ë¥¼ í†µí•´ API í˜¸ì¶œ íšŸìˆ˜ 80% ê°ì†Œ",
            "<strong>Event-Driven Architecture:</strong> ë„¤ì´í‹°ë¸Œ í”ŒëŸ¬ê·¸ì¸ê³¼ Flutter ê°„ Event Stream í†µì‹  ì„¤ê³„",
            "<strong>Generic Patterns:</strong> ì œë„¤ë¦­ íŒ¨í„´ê³¼ ì¶”ìƒí™”ë¥¼ í†µí•´ ì½”ë“œ ì¬ì‚¬ìš©ì„± ê·¹ëŒ€í™” ë° ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ"
          ]
        },
        {
          "title": "Technical Skills Demonstrated:",
          "items": [
            "<strong>Flutter Ecosystem:</strong> GetX (State Management), Native Plugins (Platform Channel), SQLite (Local DB)",
            "<strong>Algorithm Design:</strong> Adaptive Layout Algorithm, Time-Window Based Event Matching, Predictive Caching",
            "<strong>External API Integration:</strong> Google Calendar API, WebSocket, Real-time Sync"
          ]
        }
      ]
    }
  },
  "features": [
    {
      "title": "1. Zero-Latency Image Gallery Core",
      "subtitle": "ì´ë¯¸ì§€ ê°¤ëŸ¬ë¦¬ ìµœì í™” ì—”ì§„",
      "problem": "ê³ í•´ìƒë„ ìŠ¤í¬ë¦°ìƒ· ì´ë¯¸ì§€ë¥¼ PageViewë¡œ ë‹¨ìˆœíˆ êµ¬í˜„í–ˆì„ ë•Œ, ì´ë¯¸ì§€ë¥¼ ë„˜ê¸°ëŠ” ìˆœê°„(Swipe)ë§ˆë‹¤ í”„ë ˆì„ ë“œë(Jank)ê³¼ ë¡œë”© ì¸ë””ì¼€ì´í„°ê°€ ë°œìƒí•˜ëŠ” í˜„ìƒì´ ìˆì—ˆìŠµë‹ˆë‹¤.",
      "solutions": [
        "<strong>Predictive Preloading:</strong> ì‚¬ìš©ìì˜ ë„¤ë¹„ê²Œì´ì…˜ ë°©í–¥ì„ ì˜ˆì¸¡í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ìš°ì„ ì ìœ¼ë¡œ ë©”ëª¨ë¦¬ì— ì ì¬",
        "<strong>Dual-Layer Caching:</strong> ImageSizeCacheì™€ WidgetCacheë¥¼ í†µí•´ ë ˆì´ì•„ì›ƒ ì‹œí”„íŠ¸ ë°©ì§€ ë° ì¬ë Œë”ë§ ë¹„ìš© ì œê±°",
        "<strong>Smart Memory Management:</strong> ë·°í¬íŠ¸ì—ì„œ ë©€ì–´ì§„ ì´ë¯¸ì§€ëŠ” ìë™ìœ¼ë¡œ ìºì‹œì—ì„œ í•´ì œí•˜ì—¬ OOM ë°©ì§€"
      ],
      "codeKey": "cachingCode"
    },
    {
      "title": "2. Adaptive Responsive Layout Algorithm",
      "subtitle": "ì ì‘í˜• ë°˜ì‘í˜• ë ˆì´ì•„ì›ƒ ì•Œê³ ë¦¬ì¦˜",
      "problem": "ë°ìŠ¤í¬í†± ì•±ì´ì§€ë§Œ ìœˆë„ìš° í¬ê¸°ë¥¼ ììœ ë¡­ê²Œ ì¡°ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¨ìˆœíˆ ë¯¸ë””ì–´ ì¿¼ë¦¬ë‚˜ í•˜ë“œì½”ë”©ëœ ë¸Œë ˆì´í¬í¬ì¸íŠ¸ë¡œëŠ” ë‹¤ì–‘í•œ í•´ìƒë„ì™€ ì°½ í¬ê¸°ì—ì„œ ìµœì ì˜ UXë¥¼ ì œê³µí•  ìˆ˜ ì—†ì—ˆìŠµë‹ˆë‹¤. íŠ¹íˆ ì¢Œìš° ì‚¬ì´ë“œë°”, ë©”ì¸ ì»¨í…ì¸ , ìƒì„¸ íŒ¨ë„ì´ ìˆëŠ” 3ë‹¨ ë ˆì´ì•„ì›ƒì—ì„œëŠ” ê° ì˜ì—­ì´ ë™ì ìœ¼ë¡œ ì¼œì§€ê³  êº¼ì ¸ì•¼ í–ˆìŠµë‹ˆë‹¤.",
      "solutions": [
        "<strong>Viewport-Aware Calculation:</strong> í˜„ì¬ ë·°í¬íŠ¸ ë„ˆë¹„ì—ì„œ í•„ìˆ˜ ì˜ì—­(ì‚¬ì´ë“œë°”, ì—¬ë°± ë“±)ì„ ëº€ ë‚˜ë¨¸ì§€ ê³µê°„ì„ ê³„ì‚°í•˜ì—¬ ë©”ì¸ ì˜ì—­ê³¼ ìƒì„¸ íŒ¨ë„ì˜ í‘œì‹œ ì—¬ë¶€ ê²°ì •",
        "<strong>Priority-Based Rendering:</strong> ê³µê°„ì´ ë¶€ì¡±í•  ë•Œ ì‚¬ì´ë“œë°” â†’ ìƒì„¸ íŒ¨ë„ â†’ ë©”ì¸ ì˜ì—­ ìˆœìœ¼ë¡œ ìš°ì„ ìˆœìœ„ë¥¼ ë‘ì–´ í•µì‹¬ ê¸°ëŠ¥ì´ í•­ìƒ ë³´ì´ë„ë¡ ì„¤ê³„",
        "<strong>Threshold-Based Toggling:</strong> ë‹¨ìˆœ on/offê°€ ì•„ë‹Œ, ì„ê³„ê°’ ê¸°ë°˜ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ë ˆì´ì•„ì›ƒ ì „í™˜ (ì˜ˆ: ë©”ì¸ ì˜ì—­ ìµœì†Œ 600px í™•ë³´ ì‹œì—ë§Œ ìƒì„¸ íŒ¨ë„ í‘œì‹œ)"
      ],
      "codeKey": "adaptiveLayoutCode"
    },
    {
      "title": "3. Desktop-Class Keyboard Interaction",
      "subtitle": "ë°ìŠ¤í¬í†±ê¸‰ í‚¤ë³´ë“œ ì¸í„°ë™ì…˜",
      "problem": "ë°ìŠ¤í¬í†± ì•±ì—ì„œëŠ” ë§ˆìš°ìŠ¤ ì—†ì´ í‚¤ë³´ë“œë§Œìœ¼ë¡œ ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì„ íƒí•˜ê³  ì´ë™í•˜ê³  ì‹¶ì–´ í•˜ëŠ” ë‹ˆì¦ˆê°€ ìˆìŠµë‹ˆë‹¤. ë‹¨ìˆœí•œ TextFieldëŠ” ë°©í–¥í‚¤ ì…ë ¥ì„ ì»¤ì„œ ì´ë™ìœ¼ë¡œ ì†Œë¹„í•´ë²„ë¦¬ê¸° ë•Œë¬¸ì—, ì´ë¥¼ ê°€ë¡œì±„ëŠ” ë¡œì§ì´ í•„ìš”í–ˆìŠµë‹ˆë‹¤.",
      "solutions": [
        "<strong>Event Interception:</strong> FocusNodeì˜ onKeyEvent ë‹¨ê³„ì—ì„œ í‚¤ ì…ë ¥ì„ ë¨¼ì € ê²€ì‚¬í•˜ì—¬ ê²€ìƒ‰ ì»¨íŠ¸ë¡¤ëŸ¬ë¡œ ë¼ìš°íŒ…",
        "<strong>State Locking:</strong> ë§ˆìš°ìŠ¤ í˜¸ë²„ì™€ í‚¤ë³´ë“œ ì„ íƒ ê°„ì˜ ì¶©ëŒì„ ë°©ì§€í•˜ê¸° ìœ„í•œ ìƒíƒœ ì ê¸ˆ êµ¬í˜„",
        "<strong>Viewport Synchronization:</strong> ì„ íƒëœ ì•„ì´í…œì´ í•­ìƒ í™”ë©´ì— ë³´ì´ë„ë¡ ìŠ¤í¬ë¡¤ ë™ê¸°í™”"
      ],
      "codeKey": "keyboardCode"
    },
    {
      "title": "4. Generic Search & Scroll Orchestration",
      "subtitle": "ì¶”ìƒí™”ëœ ê²€ìƒ‰ ë° ìŠ¤í¬ë¡¤ ë¡œì§",
      "problem": "'ìŠ¤í‚¬(Skill)' ê²€ìƒ‰ê³¼ 'ìŠ¤í¬ë¦°ìƒ·(Screenshot)' ê²€ìƒ‰ì€ ë°ì´í„° êµ¬ì¡°ë„ ë‹¤ë¥´ê³ , UI í˜•íƒœ(ì„¸ë¡œ ë¦¬ìŠ¤íŠ¸ vs ê°€ë¡œ ë¦¬ìŠ¤íŠ¸)ë„ ë‹¤ë¦…ë‹ˆë‹¤. ê°ê° ë³„ë„ì˜ ë¡œì§ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ ì½”ë“œ ì¤‘ë³µì´ ë°œìƒí•©ë‹ˆë‹¤.",
      "solutions": [
        "<strong>Abstracted Initialization:</strong> ì–´ë–¤ ë°ì´í„° ë¦¬ìŠ¤íŠ¸ì™€ ìŠ¤í¬ë¡¤ ì»¨íŠ¸ë¡¤ëŸ¬ê°€ ë“¤ì–´ì˜¤ë“  í•„í„°ë§ í•¨ìˆ˜ë§Œ ì£¼ì…í•˜ë©´ ë™ì‘í•˜ë„ë¡ ì„¤ê³„ (Strategy Pattern)",
        "<strong>Viewport Aware Scrolling:</strong> ì„ íƒëœ ì¸ë±ìŠ¤ê°€ ë·°í¬íŠ¸ë¥¼ ë²—ì–´ë‚¬ëŠ”ì§€ ê³„ì‚°í•˜ì—¬ í•„ìš”í•œ ë§Œí¼ë§Œ ìŠ¤í¬ë¡¤"
      ],
      "codeKey": "searchCode"
    },
    {
      "title": "5. Real-Time Calendar Event Monitoring",
      "subtitle": "ì‹¤ì‹œê°„ ìº˜ë¦°ë” ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§",
      "problem": "ì‚¬ìš©ìê°€ ë¯¸íŒ…ì„ ì‹œì‘í•  ë•Œ, í•´ë‹¹ ë¯¸íŒ…ì´ Google Calendar ì´ë²¤íŠ¸ì™€ ì—°ê²°ë˜ì–´ì•¼ ì°¸ì„ì ì •ë³´, ì œëª©, ì‹œê°„ ë“±ì´ ìë™ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤. ë˜í•œ ì•ìœ¼ë¡œ ë‹¤ê°€ì˜¬ ì´ë²¤íŠ¸(upcoming event)ë¥¼ ë¯¸ë¦¬ ìºì‹±í•˜ì—¬ ë¹ ë¥´ê²Œ í‘œì‹œí•´ì•¼ í–ˆìŠµë‹ˆë‹¤. API í˜¸ì¶œ ë¹„ìš©ì„ ì¤„ì´ê³  ì‹¤ì‹œê°„ ë™ê¸°í™”ê°€ í•„ìš”í–ˆìŠµë‹ˆë‹¤.",
      "solutions": [
        "<strong>Time-Window Based Filtering:</strong> ë¦¬ìŠ¤ë‹ ì‹œì‘ ì‹œê°„ ê¸°ì¤€ Â±10ë¶„ ë²”ìœ„ ë‚´ì˜ ì´ë²¤íŠ¸ë§Œ ì¡°íšŒí•˜ì—¬ ë¶ˆí•„ìš”í•œ API í˜¸ì¶œ ìµœì†Œí™”",
        "<strong>Incremental Sync:</strong> Google Calendar APIì˜ syncTokenì„ í™œìš©í•˜ì—¬ ë³€ê²½ëœ ì´ë²¤íŠ¸ë§Œ ë™ê¸°í™” (API í˜¸ì¶œ 80% ê°ì†Œ)",
        "<strong>Multi-Criteria Matching:</strong> ë¯¸íŒ… ë§í¬, ì°¸ì„ì ìˆ˜, ì‹œê°„ ì°¨ì´ ë“± ì—¬ëŸ¬ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì´ë²¤íŠ¸ë§Œ ì„ íƒ",
        "<strong>Upcoming Event Pre-fetching:</strong> í˜„ì¬ ì‹œê°„ ê¸°ì¤€ í–¥í›„ 24ì‹œê°„ ë‚´ ì´ë²¤íŠ¸ë¥¼ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¯¸ë¦¬ ê°€ì ¸ì™€ ë¡œì»¬ DBì— ìºì‹±"
      ],
      "codeKeys": ["calendarFetchCode", "calendarUpcomingCode"]
    },
    {
      "title": "6. Event-Conversation Linking System",
      "subtitle": "ì´ë²¤íŠ¸-ëŒ€í™” ì—°ê²° ì‹œìŠ¤í…œ",
      "problem": "ì‚¬ìš©ìê°€ ë…¹ìŒì„ ì‹œì‘í•˜ë©´, í•´ë‹¹ ë…¹ìŒì´ ì–´ë–¤ ìº˜ë¦°ë” ì´ë²¤íŠ¸ì™€ ì—°ê²°ë˜ëŠ”ì§€ ìë™ìœ¼ë¡œ ë§¤ì¹­í•´ì•¼ í•©ë‹ˆë‹¤. ë‹¨ìˆœíˆ ì‹œê°„ë§Œ ë¹„êµí•˜ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë¯€ë¡œ, ë¯¸íŒ… URL, ì°¸ì„ì ìˆ˜, ì‹œê°„ ë²”ìœ„ ë“± ì—¬ëŸ¬ ì¡°ê±´ì„ ì¢…í•©ì ìœ¼ë¡œ ê³ ë ¤í•´ì•¼ í–ˆìŠµë‹ˆë‹¤.",
      "solutions": [
        "<strong>Meeting Guard Pattern:</strong> ì´ë²¤íŠ¸ê°€ ì‹¤ì œ ë¯¸íŒ…ì¸ì§€ ê²€ì¦í•˜ëŠ” ë‹¤ë‹¨ê³„ í•„í„°ë§ (ë¯¸íŒ… URL ì¡´ì¬ ì—¬ë¶€, ì°¸ì„ì 2ëª… ì´ìƒ, ì·¨ì†Œë˜ì§€ ì•ŠìŒ ë“±)",
        "<strong>Time-Based Scoring:</strong> ë…¹ìŒ ì‹œì‘ ì‹œê°„ê³¼ ì´ë²¤íŠ¸ ì‹œê°„ì˜ ì°¨ì´ë¥¼ ì ìˆ˜í™”í•˜ì—¬ ê°€ì¥ ê·¼ì ‘í•œ ì´ë²¤íŠ¸ ì„ íƒ",
        "<strong>Automatic Association:</strong> ì„ íƒëœ ì´ë²¤íŠ¸ì˜ attendeesë¥¼ ë¡œì»¬ DBì— ìë™ìœ¼ë¡œ ì €ì¥í•˜ì—¬ ëŒ€í™” ì°¸ì„ì ëª©ë¡ìœ¼ë¡œ í™œìš©"
      ],
      "codeKeys": ["eventLinkingCode", "meetingGuardCode"]
    },
    {
      "title": "7. Complex Entity Management & Form UX",
      "subtitle": "ë³µì¡í•œ ì—”í‹°í‹° ê´€ë¦¬ ë° í¼ UX",
      "problem": "í™”ì ì´ë¦„ì„ ìˆ˜ì •í•  ë•Œ, ë‹¨ìˆœíˆ í…ìŠ¤íŠ¸ë§Œ ë°”ê¾¸ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì´ë©”ì¼/ì´ë¦„ ë§¤ì¹­ì„ í†µí•´ ê¸°ì¡´ ì—°ë½ì²˜(Contact)ì™€ ìë™ìœ¼ë¡œ ì—°ê²°í•´ì•¼ í–ˆìŠµë‹ˆë‹¤. íŠ¹íˆ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í™”ì ì´ë¦„ìœ¼ë¡œ ë³€ê²½ ì‹œ, ë‘ í™”ìì˜ ë°œí™” ë°ì´í„°ë¥¼ ë³‘í•©(Merge)í•˜ê³  ë§ˆìš°ìŠ¤ ì—†ì´ í‚¤ë³´ë“œë§Œìœ¼ë¡œ ê²€ìƒ‰, ì„ íƒ, ì ìš©ì´ ê°€ëŠ¥í•œ ë¹ ë¥¸ ì›Œí¬í”Œë¡œìš°ê°€ í•„ìš”í–ˆìŠµë‹ˆë‹¤.",
      "solutions": [
        "<strong>Intelligent Merging System:</strong> ë³€ê²½í•˜ë ¤ëŠ” ì´ë¦„ì´ ì´ë¯¸ ì¡´ì¬í•˜ê±°ë‚˜ íŠ¹ì • ì´ë©”ì¼ê³¼ ë§¤ì¹­ë  ê²½ìš°, DB íŠ¸ëœì­ì…˜ì„ í†µí•´ í™”ì ì•„ì´ë””ë¥¼ í†µí•©í•˜ê³  ê´€ë ¨ ì°¸ì¡°(Foreign Key)ë¥¼ ëª¨ë‘ ì—…ë°ì´íŠ¸",
        "<strong>Keyboard-Centric Control:</strong> FocusNodeì™€ KeyEventë¥¼ ì •êµí•˜ê²Œ ì œì–´í•˜ì—¬, í™”ì‚´í‘œ ì´ë™, ìˆ«ì ë‹¨ì¶•í‚¤(Cmd+1~9) ì„ íƒ, ì—”í„° ì ìš© ë“± ë§ˆìš°ìŠ¤ ì—†ëŠ” ì™„ì „í•œ ì œì–´ êµ¬í˜„",
        "<strong>Context-Aware Searching:</strong> ë³¸ì¸(Me), íšŒì˜ ì°¸ì„ì, ì „ì²´ ì—°ë½ì²˜ ìˆœìœ¼ë¡œ ìš°ì„ ìˆœìœ„ë¥¼ ë¶€ì—¬í•œ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ ì ìš©"
      ],
      "codeKey": "assignSpeakerCode"
    }
  ],
  "techStacks": [
    {
      "items": [
        "Flutter",
        "Dart",
        "GetX",
        "SQLite",
        "Native Plugins",
        "Google Calendar API",
        "WebSocket"
      ]
    }
  ],
  "performanceMetrics": [
    { "label": "Image Loading Time", "value": "0ms (Preloaded)" },
    { "label": "API Call Reduction", "value": "80% (Incremental Sync)" },
    { "label": "Memory Efficiency", "value": "Smart Cache Cleanup" },
    { "label": "Keyboard Support", "value": "100% Navigation" }
  ],
  "codeSnippets": {
    "cachingCode": "/// Smart Caching System with Predictive Preloading\nvoid _preloadImagesForNavigation(int oldIndex, int newIndex) {\n  // 1. Direction analysis\n  final direction = newIndex > oldIndex ? 1 : -1;\n\n  // 2. Priority queue construction\n  final indicesToLoad = <int>[newIndex]; // Critical\n\n  if (direction > 0 && newIndex < screenshots.length - 1) {\n    indicesToLoad.add(newIndex + 1); // High priority\n  } else if (direction < 0 && newIndex > 0) {\n    indicesToLoad.add(newIndex - 1);\n  }\n\n  // 3. Async preloading (non-blocking UI)\n  for (final index in indicesToLoad) {\n    final path = screenshots[index]['screenshotFilePath'];\n    if (path != null && !_imageCache.containsKey(path)) {\n      _preloadImage(path);\n    }\n  }\n\n  // 4. Memory management\n  _cleanupCacheDelayed(indicesToLoad);\n}",
    "adaptiveLayoutCode": "/// Adaptive Layout Calculator\nbool _shouldShowDetail(double screenWidth) {\n  // Calculate available space after essential elements\n  const sidebarWidth = 240.0;\n  const padding = 32.0;\n  const mainMinWidth = 600.0;  // Minimum for main content\n  const detailMinWidth = 400.0; // Minimum for detail panel\n\n  final availableWidth = screenWidth - sidebarWidth - padding;\n\n  // Priority-based rendering\n  if (availableWidth < mainMinWidth) {\n    return false; // Not enough space even for main\n  }\n\n  if (availableWidth < mainMinWidth + detailMinWidth) {\n    return false; // Main area would be too cramped\n  }\n\n  return true; // Enough space for both\n}\n\n@override\nWidget build(BuildContext context) {\n  return LayoutBuilder(\n    builder: (context, constraints) {\n      final showDetail = _shouldShowDetail(constraints.maxWidth);\n\n      return Row(\n        children: [\n          Sidebar(width: 240),\n          Expanded(\n            flex: showDetail ? 3 : 1,\n            child: MainContent(),\n          ),\n          if (showDetail)\n            Expanded(\n              flex: 2,\n              child: DetailPanel(),\n            ),\n        ],\n      );\n    },\n  );\n}",
    "keyboardCode": "/// Event Routing Architecture\nKeyEventResult handleAskInputFieldKey(KeyEvent event, bool isDisabled) {\n  if (event is! KeyDownEvent) return KeyEventResult.ignored;\n\n  // Screenshot search mode\n  if (isScreenshotSearchVisible.value && filteredScreenshotList.isNotEmpty) {\n    if (event.logicalKey == LogicalKeyboardKey.arrowRight) {\n      if (selectedScreenshotIndex.value < filteredScreenshotList.length - 1) {\n        // State locking to prevent mouse hover conflicts\n        _setKeyboardNavigationState(true);\n\n        selectedScreenshotIndex.value++;\n        scrollToSelectedScreenshotItem(); // Viewport sync\n      }\n      return KeyEventResult.handled; // Prevent cursor movement\n    }\n\n    else if (event.logicalKey == LogicalKeyboardKey.enter) {\n      selectScreenshot(\n        filteredScreenshotList[selectedScreenshotIndex.value],\n        closeSearch: true\n      );\n      return KeyEventResult.handled;\n    }\n  }\n\n  return KeyEventResult.ignored;\n}",
    "searchCode": "/// Generic Search Initialization with Strategy Pattern\nvoid _initializeSearch({\n  required RxBool isVisible,\n  required RxList filteredList,\n  required List<dynamic> sourceData,\n  required Function(List<dynamic>) filterFunction,\n}) {\n  // 1. Data filtering\n  try {\n    if (query.isEmpty) {\n      filteredList.assignAll(sourceData.cast<Map<String, dynamic>>());\n    } else {\n      final filtered = filterFunction(sourceData);\n      filteredList.assignAll(filtered.cast<Map<String, dynamic>>());\n    }\n  } catch (e) {\n    filteredList.clear();\n  }\n\n  // 2. Visibility state management\n  if (!isVisible.value) {\n    isVisible.value = true;\n    selectedIndex.value = 0;\n  }\n\n  // 3. Post-frame scroll adjustment\n  if (onScrollToSelected != null) {\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      onScrollToSelected();\n    });\n  }\n}",
    "calendarFetchCode": "/// Time-Window Based Event Fetching with Incremental Sync\nFuture<void> fetchEventsForListening() async {\n  if (!isConnected.value) return;\n\n  // UTC time calculation (timezone-safe)\n  final utcNow = DateTime.now().toUtc();\n  final startTime = utcNow.subtract(const Duration(minutes: 10));\n  final endTime = utcNow.add(const Duration(minutes: 10));\n\n  // Duplicate request prevention\n  final requestKey = 'listening:$startTime-$endTime';\n  if (_shouldSkipRequest(requestKey)) return;\n\n  try {\n    // Incremental sync if syncToken exists\n    if (localEventCount > 0 && _lastSyncToken.value.isNotEmpty) {\n      await fetchChangedEvents(startTime: startTime, endTime: endTime);\n      return;\n    }\n\n    // Full sync\n    final response = await Api.getCalendarEvents(\n      type: 'full',\n      startTime: startTime.toIso8601String(),\n      endTime: endTime.toIso8601String(),\n      syncToken: _lastSyncToken.value,\n    );\n\n    // Extract and save syncToken\n    if (response['syncToken'] != null) {\n      _lastSyncToken.value = response['syncToken'].toString();\n    }\n\n    // Multi-criteria filtering\n    final filteredEvents = newEvents\n        .whereType<Map<String, dynamic>>()\n        .where((event) => _passesMeetingGuards(event))\n        .toList();\n  } finally {\n    _endRequest();\n  }\n}",
    "calendarUpcomingCode": "/// Upcoming Event Pre-fetching\nFuture<void> fetchUpcomingEvents() async {\n  final now = DateTime.now().toUtc();\n  final endTime = now.add(const Duration(hours: 24));\n\n  final response = await Api.getCalendarEvents(\n    type: 'upcoming',\n    startTime: now.toIso8601String(),\n    endTime: endTime.toIso8601String(),\n  );\n\n  // Store in local DB for quick access\n  final events = (response['items'] as List?)\n      ?.whereType<Map<String, dynamic>>()\n      .toList() ?? [];\n\n  for (final event in events) {\n    await CalendarEventDb.upsert(event);\n  }\n}",
    "eventLinkingCode": "/// Event-Conversation Linking\nFuture<void> linkEventToConversation(String conversationId) async {\n  final listeningStartTime = DateTime.now();\n\n  // Get events within time window\n  final events = await CalendarEventDb.getEventsInRange(\n    startTime: listeningStartTime.subtract(const Duration(minutes: 10)),\n    endTime: listeningStartTime.add(const Duration(minutes: 10)),\n  );\n\n  // Filter by meeting guards\n  final validEvents = events.where(_passesMeetingGuards).toList();\n\n  if (validEvents.isEmpty) return;\n\n  // Score by time proximity\n  final scoredEvents = validEvents.map((event) {\n    final eventStart = DateTime.parse(event['start']['dateTime']);\n    final timeDiff = eventStart.difference(listeningStartTime).abs();\n    return {'event': event, 'score': timeDiff.inMinutes};\n  }).toList();\n\n  scoredEvents.sort((a, b) => a['score'].compareTo(b['score']));\n\n  // Link best match\n  final bestMatch = scoredEvents.first['event'];\n  await ConversationDb.updateEventId(conversationId, bestMatch['id']);\n\n  // Store attendees\n  final attendees = bestMatch['attendees'] as List?;\n  if (attendees != null) {\n    for (final attendee in attendees) {\n      await AttendeeDb.upsert(conversationId, attendee);\n    }\n  }\n}",
    "meetingGuardCode": "/// Meeting Guard Pattern\nbool _passesMeetingGuards(Map<String, dynamic> event) {\n  // Guard 1: Must have meeting URL\n  final hangoutLink = event['hangoutLink'];\n  if (hangoutLink == null || hangoutLink.isEmpty) return false;\n\n  // Guard 2: Must have attendees (at least 2)\n  final attendees = event['attendees'] as List?;\n  if (attendees == null || attendees.length < 2) return false;\n\n  // Guard 3: Must not be cancelled\n  final status = event['status'];\n  if (status == 'cancelled') return false;\n\n  // Guard 4: Must have valid time\n  final start = event['start'];\n  if (start == null || start['dateTime'] == null) return false;\n\n  return true;\n}",
    "assignSpeakerCode": "/// [Intelligent Speaker Merging & Update Logic]\n/// í™”ì ì •ë³´ ì—…ë°ì´íŠ¸ ì‹œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë³‘í•©/ì¶©ëŒ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì²˜ë¦¬í•˜ê³ \n/// DBì˜ ë¬´ê²°ì„±ì„ ìœ ì§€í•˜ë©° ê´€ë ¨ ë°ì´í„°ë¥¼ ì¼ê´„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\nFuture<void> _updateExistingSpeaker(int spkrIdx, String newName) async {\n  // 1. ì´ë©”ì¼/ì´ë¦„ìœ¼ë¡œ ê¸°ì¡´ í™”ì ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (ì¤‘ë³µ ì²´í¬)\n  final existingAttendee = await AttendeeDb.findAttendeeByName(newName);\n  if (existingAttendee != null) {\n    // [Merge Case] ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í™”ìë¼ë©´ ë°ì´í„°ë¥¼ ë³‘í•©\n    final targetSpkrIdx = existingAttendee['speakerIndex'];\n\n    // 1. ê¸°ì¡´ í™”ìì˜ ë°œí™”(Transcript) ì†Œìœ ê¶Œì„ ìƒˆ í™”ìë¡œ ì´ì „\n    await SpeakerDb.modifyTranscriptSpeaker(\n      oldSpkrIdx: spkrIdx,\n      newSpkrIdx: targetSpkrIdx\n    );\n\n    // 2. Attendee ë° Contact ì •ë³´ í†µí•©\n    await AttendeeDb.mergeInfo(oldSpkrIdx, targetSpkrIdx);\n\n    // 3. ì´ì „ í™”ì ë ˆì½”ë“œ ì‚­ì œ (Clean up)\n    await SpeakerDb.deleteSpeaker(spkrIdx);\n  } else {\n    // [Update Case] ë‹¨ìˆœ ì •ë³´ ì—…ë°ì´íŠ¸\n    await SpeakerDb.updateSpeaker(\n      spkrIdx: spkrIdx,\n      spkrName: newName,\n      spkrState: 'confirmed'\n    );\n\n    // ëª¨ë“  ì°¸ì¡°ëœ í…ìŠ¤íŠ¸(ìš”ì•½, ë…¸íŠ¸ ë“±)ì—ì„œë„ ì´ë¦„ ë³€ê²½\n    await _updateDataForAllReferences(oldName, newName);\n  }\n}\n\n/// [Keyboard Navigation Handler]\n/// ë¦¬ìŠ¤íŠ¸ íƒìƒ‰ê³¼ ë‹¨ì¶•í‚¤ ì„ íƒì„ ì²˜ë¦¬í•˜ì—¬ ë§ˆìš°ìŠ¤ ì—†ëŠ” ê²½í—˜ ì œê³µ\nvoid _handleArrowKeys(KeyDownEvent event) {\n  if (event.logicalKey == LogicalKeyboardKey.arrowDown) {\n    // ë¦¬ìŠ¤íŠ¸ ìˆœí™˜ íƒìƒ‰ (ë§ˆì§€ë§‰ -> ì²˜ìŒ)\n    int nextIndex = selectedIndex.value + 1;\n    if (nextIndex >= displayList.length) nextIndex = 0;\n\n    _selectItemByIndex(nextIndex);\n    _scrollToSelectedIndex(); // ë·°í¬íŠ¸ ë™ê¸°í™”\n  }\n  // ... (ArrowUp, Enter, Cmd+Number ì²˜ë¦¬)\n}"
  }
}
